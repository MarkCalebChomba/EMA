import time
import ccxt
import pandas as pd
import logging
from datetime import datetime

# ----------------- Logging Setup -----------------
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("DualTFTradingBot")

# ----------------- API Credentials & Trading Configuration -----------------
API_CREDENTIALS = {
    'api_key': '544d6587-0a7d-4b73-bb06-0e3656c08a18',
    'secret_key': '9C2CA165254391E4B4638DE6577288BD',
    'passphrase': '#Dinywa15'
}

TRADING_CONFIG = {
    'symbol': "DOGE/USDT:USDT",
    'leverage': 50,
    'contract_size': 0.01,
    # Timeframes: 15-minute for entry; 1-minute for confirmation and exit.
    'entry_timeframe': "15m",
    'exit_timeframe': "1m"
}

# ----------------- Bot Class -----------------
class DualTFTradingBot:
    def __init__(self, sandbox_mode=True):
        """
        Initialize the bot:
         - Creates the OKX exchange instance with provided API credentials.
         - Sets sandbox mode appropriately.
         - Initializes internal state.
        """
        try:
            self.exchange = ccxt.okx({
                'apiKey': API_CREDENTIALS['api_key'],
                'secret': API_CREDENTIALS['secret_key'],
                'password': API_CREDENTIALS['passphrase'],
                'enableRateLimit': True,
                'options': {'defaultType': 'swap'}
            })
            # Set sandbox mode; make sure your API key is for the correct environment.
            self.exchange.set_sandbox_mode(sandbox_mode)
            logger.info(f"Exchange initialized successfully (Sandbox Mode: {sandbox_mode})")
        except Exception as e:
            logger.error(f"Error initializing exchange: {e}")
            raise

        self.symbol = TRADING_CONFIG['symbol']
        self.leverage = TRADING_CONFIG['leverage']
        self.contract_size = TRADING_CONFIG['contract_size']
        self.entry_timeframe = TRADING_CONFIG['entry_timeframe']
        self.exit_timeframe = TRADING_CONFIG['exit_timeframe']

        # Internal state: positions, current signal and running flag.
        self.positions = []         # List of open positions
        self.current_signal = None  # "buy" or "sell"
        self.running = False

    def set_leverage(self):
        """
        Set the desired leverage on the exchange.
        """
        try:
            self.exchange.set_leverage(self.leverage, self.symbol)
            logger.info(f"Leverage set to {self.leverage}x for {self.symbol}")
        except Exception as e:
            logger.error(f"Failed to set leverage: {e}")

    def fetch_ohlcv(self, timeframe, limit=250):
        """
        Fetches OHLCV data from the exchange for a given timeframe.
        Calculates EMAs (for entry: EMA30, EMA60; for exit: EMA10, EMA30).
        """
        try:
            ohlcv = self.exchange.fetch_ohlcv(
                symbol=self.symbol,
                timeframe=timeframe,
                limit=limit
            )
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)

            # Calculate required EMAs:
            if timeframe == self.entry_timeframe:
                # For entry signals, we need EMA30 and EMA60 (and optionally EMA10 for a higher timeframe check)
                df['ema_30'] = df['close'].ewm(span=30, adjust=False).mean()
                df['ema_60'] = df['close'].ewm(span=60, adjust=False).mean()
                # Optional: also calculate EMA10 on 15m if needed.
                df['ema_10'] = df['close'].ewm(span=10, adjust=False).mean()
            elif timeframe == self.exit_timeframe:
                # For exit and confirmation signals, we need EMA30, EMA60 and EMA10.
                df['ema_30'] = df['close'].ewm(span=30, adjust=False).mean()
                df['ema_60'] = df['close'].ewm(span=60, adjust=False).mean()
                df['ema_10'] = df['close'].ewm(span=10, adjust=False).mean()
            return df
        except Exception as e:
            logger.error(f"Error fetching OHLCV data for timeframe {timeframe}: {e}")
            return None

    def get_entry_signal_15m(self, df):
        """
        Determine the entry signal from 15-minute data:
          - "buy" if EMA30 > EMA60
          - "sell" if EMA30 < EMA60
        """
        try:
            ema_30 = df['ema_30'].iloc[-1]
            ema_60 = df['ema_60'].iloc[-1]
            if ema_30 > ema_60:
                return "buy"
            elif ema_30 < ema_60:
                return "sell"
            else:
                return None
        except Exception as e:
            logger.error(f"Error determining 15m entry signal: {e}")
            return None

    def get_confirmation_signal_1m(self, df):
        """
        Determine the confirmation signal from 1-minute data:
          - "buy" if EMA30 > EMA60
          - "sell" if EMA30 < EMA60
        This is used to confirm the 15-minute entry signal.
        """
        try:
            ema_30 = df['ema_30'].iloc[-1]
            ema_60 = df['ema_60'].iloc[-1]
            if ema_30 > ema_60:
                return "buy"
            elif ema_30 < ema_60:
                return "sell"
            else:
                return None
        except Exception as e:
            logger.error(f"Error determining 1m confirmation signal: {e}")
            return None

    def get_exit_signal_1m(self, df, position_type):
        """
        Check the exit condition from the 1-minute data:
          - For a long (buy) position, exit if EMA10 crosses below EMA30.
          - For a short (sell) position, exit if EMA10 crosses above EMA30.
        """
        try:
            ema_10 = df['ema_10'].iloc[-1]
            ema_30 = df['ema_30'].iloc[-1]
            if position_type == "buy" and ema_10 < ema_30:
                return True
            elif position_type == "sell" and ema_10 > ema_30:
                return True
            else:
                return False
        except Exception as e:
            logger.error(f"Error determining 1m exit signal: {e}")
            return False

    def execute_trade(self, trade_type, price):
        """
        Execute a trade:
          - For a "buy", open a long position.
          - For a "sell", open a short position.
        The bot scales into the position if conditions remain.
        """
        try:
            amount = self.contract_size
            params = {'tdMode': 'cross'}
            order = None

            if trade_type == "buy":
                # Execute a market buy order for long position.
                order = self.exchange.create_market_buy_order(
                    symbol=self.symbol, amount=amount, params={**params, 'posSide': 'long'}
                )
                self.positions.append({'type': 'buy', 'price': price, 'timestamp': datetime.now()})
                logger.info(f"Executed BUY order: {amount} at {price}")

            elif trade_type == "sell":
                # Execute a market sell order for short position.
                order = self.exchange.create_market_sell_order(
                    symbol=self.symbol, amount=amount, params={**params, 'posSide': 'short'}
                )
                self.positions.append({'type': 'sell', 'price': price, 'timestamp': datetime.now()})
                logger.info(f"Executed SELL order: {amount} at {price}")

            return order
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return None

    def close_all_positions(self):
        """
        Close all open positions immediately.
        Ensures that we don't have a mix of both buy and sell orders.
        """
        try:
            if not self.positions:
                return

            # Use the 1m timeframe to get the latest price for closing.
            df_exit = self.fetch_ohlcv(self.exit_timeframe, limit=50)
            if df_exit is None:
                logger.error("Unable to fetch data for closing positions.")
                return

            latest_price = df_exit['close'].iloc[-1]
            for position in list(self.positions):
                amount = self.contract_size
                params = {'tdMode': 'cross'}
                if position['type'] == "buy":
                    # Close long by selling
                    self.exchange.create_market_sell_order(
                        symbol=self.symbol, amount=amount, params={**params, 'posSide': 'short'}
                    )
                    logger.info(f"Closed BUY position at {latest_price}")
                elif position['type'] == "sell":
                    # Close short by buying
                    self.exchange.create_market_buy_order(
                        symbol=self.symbol, amount=amount, params={**params, 'posSide': 'long'}
                    )
                    logger.info(f"Closed SELL position at {latest_price}")
                # Remove the position from the list
                self.positions.remove(position)
            # Reset current signal after closing
            self.current_signal = None
        except Exception as e:
            logger.error(f"Error closing positions: {e}")

    def run(self):
        """
        Main trading loop:
          - Every minute, fetch both 15m and 1m data.
          - Generate an entry signal from the 15m data.
          - Confirm the entry using the 1m data.
          - Check the exit condition on the 1m data.
          - If an exit or reversal is detected, close all positions immediately.
          - Otherwise, if entry conditions are confirmed and no conflicting position exists,
            execute a trade (scaling into the position if already in a trade of the same type).
        """
        if self.running:
            logger.warning("Bot is already running.")
            return

        self.running = True
        self.set_leverage()
        logger.info(f"Bot started: Trading {self.symbol}")
        
        while self.running:
            try:
                # Fetch data for both timeframes
                df_15m = self.fetch_ohlcv(self.entry_timeframe, limit=100)
                df_1m = self.fetch_ohlcv(self.exit_timeframe, limit=100)

                if df_15m is None or df_1m is None:
                    logger.warning("Failed to fetch data for one or both timeframes, retrying...")
                    time.sleep(60)
                    continue

                # Determine primary 15m entry signal
                entry_signal_15m = self.get_entry_signal_15m(df_15m)
                # Determine 1m confirmation signal for entry
                confirm_signal_1m = self.get_confirmation_signal_1m(df_1m)

                # Check for exit signal on 1m for any open positions
                exit_trigger = False
                if self.positions:
                    # Get the type of the open position (all positions are of same type by design)
                    current_position_type = self.positions[0]['type']
                    if self.get_exit_signal_1m(df_1m, current_position_type):
                        exit_trigger = True

                # If exit trigger is met OR the 15m signal reverses (relative to open position), close all positions.
                if exit_trigger:
                    logger.info("Exit condition met on 1m. Closing all positions.")
                    self.close_all_positions()
                elif self.positions and entry_signal_15m != self.current_signal:
                    logger.info("15m signal has reversed relative to open positions. Closing all positions.")
                    self.close_all_positions()
                else:
                    # Only proceed with entry if there are no open positions OR we're scaling in on the same signal.
                    if not self.positions:
                        # Entry only if 15m signal equals 1m confirmation
                        if entry_signal_15m and entry_signal_15m == confirm_signal_1m:
                            logger.info(f"Entry confirmed: {entry_signal_15m} signal on both 15m and 1m.")
                            self.execute_trade(entry_signal_15m, df_1m['close'].iloc[-1])
                            self.current_signal = entry_signal_15m
                        else:
                            logger.info("Entry conditions not met on 1m confirmation.")
                    else:
                        # If positions are already open and the signal is the same,
                        # scale into the position (i.e. add another trade).
                        if entry_signal_15m and entry_signal_15m == self.current_signal and entry_signal_15m == confirm_signal_1m:
                            logger.info(f"Signal remains valid ({entry_signal_15m}). Scaling in at price {df_1m['close'].iloc[-1]}.")
                            self.execute_trade(entry_signal_15m, df_1m['close'].iloc[-1])
                        else:
                            logger.info("Current market conditions do not support scaling in.")

                # Wait one minute before the next cycle.
                time.sleep(60)
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                time.sleep(60)

    def stop(self):
        """
        Stops the bot and closes all open positions.
        """
        if not self.running:
            logger.warning("Bot is not running.")
            return

        self.running = False
        self.close_all_positions()
        logger.info("Bot stopped and all positions closed.")

# ----------------- Main Execution -----------------
if __name__ == "__main__":
    bot = DualTFTradingBot(sandbox_mode=True)  # Use sandbox mode; set to False for live trading.
    try:
        bot.run()
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received, stopping bot.")
        bot.stop()
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        bot.stop()
