import time
import ccxt
import pandas as pd
import logging
from datetime import datetime

# Setup logging to display bot activity
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("MLTradingBot")

# API credentials for OKX (ensure these are for your test environment if using sandbox)
API_CREDENTIALS = {
    'api_key': '544d6587-0a7d-4b73-bb06-0e3656c08a18',
    'secret_key': '9C2CA165254391E4B4638DE6577288BD',
    'passphrase': '#Dinywa15'
}

# Trading configuration parameters
TRADING_CONFIG = {
    'symbol': "DOGE/USDT:USDT",    # Trading pair
    'timeframe': "1m",             # Chart timeframe
    'leverage': 50,                # Leverage for trading
    'contract_size': 0.01,         # Trade size per order
    'stop_loss_percent': 1.0,      # Stop loss percentage
    'take_profit_percent': 2.0     # Take profit percentage
}

class MLTradingBot:
    def __init__(self, sandbox_mode=True):
        """
        Initialize the trading bot.
        - Creates the exchange instance with provided API credentials.
        - Sets sandbox mode based on the parameter.
        """
        try:
            self.exchange = ccxt.okx({
                'apiKey': API_CREDENTIALS['api_key'],
                'secret': API_CREDENTIALS['secret_key'],
                'password': API_CREDENTIALS['passphrase'],
                'enableRateLimit': True,
                'options': {'defaultType': 'swap'}
            })
            # Set sandbox mode if desired. Make sure your API keys match the selected environment.
            self.exchange.set_sandbox_mode(sandbox_mode)
            logger.info(f"Exchange initialized successfully (Sandbox Mode: {sandbox_mode})")
        except Exception as e:
            logger.error(f"Error initializing exchange: {e}")
            raise

        # Set trading parameters from configuration
        self.symbol = TRADING_CONFIG['symbol']
        self.timeframe = TRADING_CONFIG['timeframe']
        self.leverage = TRADING_CONFIG['leverage']
        self.contract_size = TRADING_CONFIG['contract_size']
        self.stop_loss_percent = TRADING_CONFIG['stop_loss_percent']
        self.take_profit_percent = TRADING_CONFIG['take_profit_percent']

        # Internal state
        self.positions = []      # List to store open positions
        self.order_history = []  # Log of orders
        self.current_signal = None  # Current market signal ("buy" or "sell")
        self.running = False

    def set_leverage(self):
        """
        Sets the leverage for the trading pair.
        """
        try:
            self.exchange.set_leverage(self.leverage, self.symbol)
            logger.info(f"Leverage set to {self.leverage}x for {self.symbol}")
        except Exception as e:
            logger.error(f"Failed to set leverage: {e}")

    def fetch_ohlcv_data(self, limit=None):
        """
        Fetches OHLCV (candlestick) data from the exchange.
        Optionally a limit can be passed for backtesting.
        Calculates the necessary EMAs for decision making:
          - EMA200: Trend bias
          - EMA60 and EMA30: Entry signals
          - EMA10: Exit signal
        """
        try:
            fetch_limit = limit if limit is not None else 250
            ohlcv = self.exchange.fetch_ohlcv(
                symbol=self.symbol,
                timeframe=self.timeframe,
                limit=fetch_limit
            )
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.set_index('timestamp', inplace=True)

            # Calculate exponential moving averages (EMAs)
            df['ema_200'] = df['close'].ewm(span=200, adjust=False).mean()
            df['ema_60'] = df['close'].ewm(span=60, adjust=False).mean()
            df['ema_30'] = df['close'].ewm(span=30, adjust=False).mean()
            df['ema_10'] = df['close'].ewm(span=10, adjust=False).mean()
            return df
        except Exception as e:
            logger.error(f"Error fetching OHLCV data: {e}")
            return None

    def check_entry_signal(self, df):
        """
        Determines the entry signal:
          - "buy" signal if EMA30 > EMA60
          - "sell" signal if EMA30 < EMA60
        """
        ema_30 = df['ema_30'].iloc[-1]
        ema_60 = df['ema_60'].iloc[-1]
        if ema_30 > ema_60:
            return "buy"
        elif ema_30 < ema_60:
            return "sell"
        return None

    def check_exit_signal(self, df, position_type):
        """
        Determines if the exit condition is met:
          - For a long position ("buy"), exit if EMA10 < EMA30.
          - For a short position ("sell"), exit if EMA10 > EMA30.
        """
        ema_10 = df['ema_10'].iloc[-1]
        ema_30 = df['ema_30'].iloc[-1]
        if position_type == "long" and ema_10 < ema_30:
            return True
        elif position_type == "short" and ema_10 > ema_30:
            return True
        return False

    def execute_trade(self, trade_type, price):
        """
        Executes a market order based on the provided trade_type.
        Logs the order and stores the new position.
        """
        try:
            amount = self.contract_size
            params = {'tdMode': 'cross'}
            order = None

            if trade_type == "buy":
                # Execute market buy order for a long position
                order = self.exchange.create_market_buy_order(
                    symbol=self.symbol, amount=amount, params={**params, 'posSide': 'long'}
                )
                position = {
                    'type': 'long',
                    'price': price,
                    'amount': amount,
                    'timestamp': datetime.now(),
                    'stop_loss': price * (1 - self.stop_loss_percent / 100),
                    'take_profit': price * (1 + self.take_profit_percent / 100)
                }
                self.positions.append(position)
                self.order_history.append({'type': 'buy', 'price': price, 'amount': amount, 'timestamp': datetime.now()})
                logger.info(f"Executed BUY order: {amount} at {price}")

            elif trade_type == "sell":
                # Execute market sell order for a short position
                order = self.exchange.create_market_sell_order(
                    symbol=self.symbol, amount=amount, params={**params, 'posSide': 'short'}
                )
                position = {
                    'type': 'short',
                    'price': price,
                    'amount': amount,
                    'timestamp': datetime.now(),
                    'stop_loss': price * (1 + self.stop_loss_percent / 100),
                    'take_profit': price * (1 - self.take_profit_percent / 100)
                }
                self.positions.append(position)
                self.order_history.append({'type': 'sell', 'price': price, 'amount': amount, 'timestamp': datetime.now()})
                logger.info(f"Executed SELL order: {amount} at {price}")

            return order
        except Exception as e:
            logger.error(f"Error executing trade: {e}")
            return None

    def close_position(self, position):
        """
        Closes a specific position by executing an opposite market order.
        """
        try:
            amount = position['amount']
            latest_price = self.fetch_ohlcv_data()['close'].iloc[-1]
            order = None
            if position['type'] == "long":
                # Close a long position with a market sell order
                order = self.exchange.create_market_sell_order(
                    symbol=self.symbol, amount=amount, params={'tdMode': 'cross', 'posSide': 'short'}
                )
                self.order_history.append({'type': 'close_long', 'price': latest_price, 'amount': amount, 'timestamp': datetime.now()})
                logger.info(f"Closed LONG position at {latest_price}")
            elif position['type'] == "short":
                # Close a short position with a market buy order
                order = self.exchange.create_market_buy_order(
                    symbol=self.symbol, amount=amount, params={'tdMode': 'cross', 'posSide': 'long'}
                )
                self.order_history.append({'type': 'close_short', 'price': latest_price, 'amount': amount, 'timestamp': datetime.now()})
                logger.info(f"Closed SHORT position at {latest_price}")
            
            self.positions.remove(position)
            return order
        except Exception as e:
            logger.error(f"Error closing position: {e}")
            return None

    def run(self):
        """
        Main live trading loop:
          - Checks market data every minute.
          - Adds a new trade if the current signal is valid and market conditions persist.
          - Closes all positions if a signal reversal occurs.
          - Continuously checks stop loss, take profit, and exit conditions.
        """
        if self.running:
            logger.warning("Bot is already running.")
            return

        self.running = True

        # Set leverage once at startup
        self.set_leverage()
        logger.info(f"Bot started: Trading {self.symbol} on {self.timeframe} timeframe")
        logger.info(f"Risk parameters: SL={self.stop_loss_percent}%, TP={self.take_profit_percent}%")

        while self.running:
            try:
                # Fetch latest market data
                df = self.fetch_ohlcv_data()
                if df is None:
                    logger.warning("Failed to fetch data, retrying in 30 seconds...")
                    time.sleep(30)
                    continue

                current_price = df['close'].iloc[-1]

                # Check for stop loss or take profit for each open position
                for position in list(self.positions):
                    if position['type'] == 'long' and current_price <= position['stop_loss']:
                        logger.info("Long position stop loss triggered.")
                        self.close_position(position)
                    elif position['type'] == 'long' and current_price >= position['take_profit']:
                        logger.info("Long position take profit triggered.")
                        self.close_position(position)
                    elif position['type'] == 'short' and current_price >= position['stop_loss']:
                        logger.info("Short position stop loss triggered.")
                        self.close_position(position)
                    elif position['type'] == 'short' and current_price <= position['take_profit']:
                        logger.info("Short position take profit triggered.")
                        self.close_position(position)

                # Check exit signal for each open position based on EMA10 vs EMA30
                for position in list(self.positions):
                    if self.check_exit_signal(df, position['type']):
                        logger.info(f"Exit signal detected for {position['type']} position.")
                        self.close_position(position)

                # Determine the current entry signal (using EMA30 vs EMA60)
                entry_signal = self.check_entry_signal(df)
                if entry_signal:
                    # If signal reversal occurs, close all open positions
                    if self.current_signal and entry_signal != self.current_signal:
                        logger.info(f"Signal changed from {self.current_signal} to {entry_signal}. Closing all positions.")
                        for position in list(self.positions):
                            self.close_position(position)
                    
                    # Update current signal and add a new trade for this minute if conditions are valid.
                    self.current_signal = entry_signal
                    logger.info(f"Market signal is '{entry_signal}'. Adding a new trade at {current_price}.")
                    self.execute_trade(entry_signal, current_price)
                else:
                    logger.info("No valid entry signal detected.")

                # Wait for 60 seconds before checking again
                time.sleep(60)
            except Exception as e:
                logger.error(f"Error in main loop: {e}")
                time.sleep(30)

    def stop(self):
        """
        Stops the bot and closes all open positions.
        """
        if not self.running:
            logger.warning("Bot is not running.")
            return

        self.running = False
        for position in list(self.positions):
            self.close_position(position)
        logger.info("Bot stopped and all positions closed.")

if __name__ == "__main__":
    # Create bot instance; change sandbox_mode to False for live trading.
    bot = MLTradingBot(sandbox_mode=True)
    
    # Uncomment the next block to run the bot for live trading.
    try:
        bot.run()
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received, stopping bot.")
        bot.stop()
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        bot.stop()
